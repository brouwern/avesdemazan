---
title: "Ecuador analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ecuador analysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(avesdemazan)
```



## Preliminaries


### Re-Install problematic packages
```{r}
# install.packages("Matrix")
# install.packages("TMB",dependencies = T)
# install.packages("glmmTMB", type="source")
```

RcppEigen?


### Load packages
```{r House-keeping, warning = FALSE, echo = T, include = FALSE}
# Data cleaning
library(dplyr)      
library(tidyr)   
library(reshape2)
library(stringi)  


# Model fitting
library(lme4)       # glmer() for glmm
library(glmmTMB)    # glmm with AR-1  
library(blme)       # bglmer (used?)

# Model evaluation
library(afex)       # functionall_fit()
library(multcomp)   
library(emmeans)
library(bbmle)      # aictab
library(arm)        # se.fit()

# Result visualization
library(ggplot2)    
library(ggstance)  
library(grid)
library(gridExtra)  

#  markdown etc
library(knitr)     

# Miscellaneous

# library(rgl)        # ?  "3D Visualization Using OpenGL"
# Error: package or namespace load failed for ‘rgl’:
#  .onLoad failed in loadNamespace() for 'rgl', details:
#   call: rgl.init(initValue, onlyNULL)
#   error: OpenGL is not available in this build
# In addition: Warning messages:
# 1: 	Loading rgl's DLL failed. 
# 	This build of rgl depends on XQuartz, which failed to load.
#  See the discussion in https://stackoverflow.com/a/66127391/2554330 
# 2: Trying without OpenGL... 
## issues with XQuartz, OpenGL
## https://stackoverflow.com/a/66127391/2554330 
  


## Community ecology
# library(iNEXT)      # rarefaction

```





## Best model 

```{r Show best model specification, eval = F, include = TRUE, warning = FALSE}
# This is the best model
fit_nb2_corr <- glmmTMB(N ~ 1 +                                         # Intercept
                          Location +                                    # Location
                          time_cts +                                    # Continuous time variable
                          (1|Specie.Code:Location) +                    # Species-level intercept
                          (time_cts + 0|Specie.Code:Location) +         # Species-level slopes
                          ar1(as.ordered(time_cts) + 0|Specie.Code) +   # Autocorrelation across time
                          offset(log(tot_net_hours)),                   # Offset effort
                        family = nbinom2,
                        data = ecuador)

```


```{r}
ranefsx <- ranef(fit_nb2_corr)
ranefsx$cond$`Specie.Code:Location`
ranefsx$cond$Specie.Code[,1:4]
```


Add (1|year)?
```{r}
# This is the best model
fit_nb2_corr.w.yr <- glmmTMB(N ~ 1 +                                         # Intercept
                          Location +                                    # Location
                          time_cts +                                    # Continuous time variable
                          (1|year) +
                          #(1|year:Location) +
                          (1|Specie.Code:Location) +                    # Species-level intercept
                          (time_cts + 0|Specie.Code:Location) +         # Species-level slopes
                          ar1(as.ordered(time_cts) + 0|Specie.Code) +   # Autocorrelation across time
                          offset(log(tot_net_hours)),                   # Offset effort
                        family = nbinom2,
                        data = ecuador)
```

```{r}

x2 <- update(fit_nb2_corr, . ~ . + time_cts*Location)
AICtab(fit_nb2_corr, x2)

```


```{r}
fixef(fit_nb2_corr)
fixef(fit_nb2_corr.w.yr)
fixef(fit_nb2_corr.w.yr2)
AICtab(fit_nb2_corr,fit_nb2_corr.w.yr, fit_nb2_corr.w.yr2)

```


Get coefficients and make table
```{r, echo = T}
best_fit_tab <- as.data.frame(summary(fit_nb2_corr)$coefficients$cond)
rownames(best_fit_tab) <- c("Intercept", "Location (MAIN)", "Location (MASE)", "Time")
kable(best_fit_tab, caption = "Model output on original (log) scale")
```

```{r, echo = T}
best_fit_tab <- as.data.frame(summary(fit_nb2_corr)$coefficients$cond)
rownames(best_fit_tab) <- c("Intercept", "Location (MAIN)", "Location (MASE)", "Time")
best_fit_tab2 <- best_fit_tab

# Point estimates
best_fit_tab2$EstimateExp <- NA

best_fit_tab2$EstimateExp[1] <- best_fit_tab2$Estimate[1]
best_fit_tab2$EstimateExp[2] <- best_fit_tab2$Estimate[1] + best_fit_tab2$Estimate[2]
best_fit_tab2$EstimateExp[3] <- best_fit_tab2$Estimate[1] + best_fit_tab2$Estimate[3]

# SE estimates
vcov <- matrix(unlist(vcov(fit_nb2_corr)), nrow = 4)

best_fit_tab2$SE <- NA

best_fit_tab2$SE[1] <- sqrt(vcov[1,1])
best_fit_tab2$SE[2] <- sqrt(vcov[1,1] + vcov[2,2] + 2*vcov[1,2])
best_fit_tab2$SE[3] <- sqrt(vcov[1,1] + vcov[3,3] + 2*vcov[1,3])

# Lower bound & upper bound
best_fit_tab2$LB <- round(exp(best_fit_tab2$EstimateExp - 1.96*best_fit_tab2$SE), 6)*1000
best_fit_tab2$UB <- round(exp(best_fit_tab2$EstimateExp + 1.96*best_fit_tab2$SE), 6)*1000

# Calculate confidence interval
best_fit_tab2$CI <- paste0("(", best_fit_tab2$LB, ", ", best_fit_tab2$UB, ")")

# Point Estimate
best_fit_tab2$EstimateExp <- round(exp(best_fit_tab2$EstimateExp), 6) * 1000

# Drop time effect row
best_fit_tab2 <- best_fit_tab2[-4,]

# Select point estimate and 95% CI columns
best_fit_tab2 <- best_fit_tab2[,c(5,9)]

# Format
rownames(best_fit_tab2) <- c("Secondary forest (LLAV)", "Introduced forest (MAIN)", "Primary forest (MASE)")
colnames(best_fit_tab2) <- c("Baseline captures per 1,000 net hours", "95% Confidence Interval")
kable(best_fit_tab2, caption = "Transformed model estimates")
```

We estimate that the baseline (time = 0) capture rate per 1,000 net hours is 7.191 (95\% CI (5.383, 9.606)) in secondary forest, 5.820 (95\% CI (4.226, 8.015)) in introduced forest, and 4.423 (95\% CI (3.153, 6.206)) in primary forest. We estimate a 2.8\% (95\% CI (0.9\%, 4.6\%)) decrease in capture rate between years in all habitats. **

```{r Store standard errors, echo = T, fig.height = 7.25}
s1 <- TMB::sdreport(fit_nb2_corr$obj, getJointPrecision = TRUE, bias.correct = TRUE)
s2 <- sqrt(s1$diag.cov.random)

test <- solve(s1$jointPrecision)

parameters <- fit_nb2_corr$obj$env$par
parameters <- as.data.frame(parameters)
parameters$names <- names(fit_nb2_corr$obj$env$par)
parameters$sd <- sqrt(diag(test))

parameters$variable <- NA
parameters$variable[1:162] <- c("(Intercept)","LocationMAIN","LocationMASE","time_cts", rep("Intercept", 79), rep("time_cts", 79))

parameters$spp <- NA
parameters$spp[1:162] <- c(rep("Population", 4), rownames(ranef(fit_nb2_corr)[[1]]$`Specie.Code:Location`), rownames(ranef(fit_nb2_corr)[[1]]$`Specie.Code:Location`))

parameters$aggregate_sd <- NA

for (i in 0:78)
{
  parameters$aggregate_sd[84+i] <- sqrt(test[4,4] + test[84+i,84+i] + 2*test[84+i,4])
}

subset_for_merge <- parameters[84:162,c("spp","aggregate_sd")]
colnames(subset_for_merge)[1] <- "id"

sd_int   <- s2[1:79]
sd_slope <- s2[80:158]

slopes <- ranef(fit_nb2_corr)[[1]]$`Specie.Code:Location` # 79 x 2
#ranef(fit_nb2_corr)[[1]]$`Specie.Code` # 38 x 33
# 79 * 2 + 38 * 33

s0 <- fit_nb2_corr$sdr

                       #time coefficient                      # ? individual time slope?
slopes$time_cts_tot <- summary(fit_nb2_corr)[[6]]$cond[4,1] + slopes$time_cts
slopes$time_sd  <- sd_slope
slopes$time_lb  <- slopes$time_cts_tot - 1.96*slopes$time_sd
slopes$time_ub  <- slopes$time_cts_tot + 1.96*slopes$time_sd

slopes$spp <- substring(rownames(slopes), 1, 4)
slopes$loc <- substring(rownames(slopes), 6, 9)
slopes$id <- rownames(slopes)

slopes.unique <- slopes[!duplicated(slopes$spp),]

slopes$spp2 <- ordered(slopes$spp, levels = slopes.unique[order(slopes.unique$time_cts_tot),]$spp)
slopes$id2 <- ordered(slopes$id, levels = slopes[order(slopes$time_cts_tot),]$id)

slopes <- left_join(slopes, subset_for_merge, by = "id")

# calculate lower (lb) and upper (ub) bound of CIs
## NOTE: use slopes$time_cts_tot (as shown and as was in orig script)
###      NOTE time_cts
slopes$time_lb2  <- slopes$time_cts_tot - 1.96*slopes$aggregate_sd
slopes$time_ub2  <- slopes$time_cts_tot + 1.96*slopes$aggregate_sd

# ggplot(data = slopes, aes(x = time_cts, y = slopes$spp2)) +
#   geom_point(aes(x = time_cts, y = spp2)) +
#   geom_segment(aes(x = time_lb, xend = time_ub, y = spp2, yend = spp2)) +
#   facet_grid(~loc) +
#   geom_vline(aes(xintercept = 0, color = "No Change")) +
#   geom_vline(aes(xintercept = summary(fit_nb2_corr)[[6]]$cond[4,1], color = "Population-level estimate")) +
#   #geom_rect(aes(xmin = -0.016779 - 1.96*0.003354, xmax = -0.016779 + 1.96*0.003354, ymin = -Inf, ymax = Inf), fill = "blue", alpha = 0.2) +
#   xlab("Species-level time coefficient \n") + ylab("Species Code") +
#   #scale_colour_manual(values = c("Population-level estimate" = "blue")) +
#   scale_colour_manual(values =c("No Change" = "red", "Population-level estimate" = "blue")) +
#   #scale_fill_manual(values = c("blue" = "blue")) +
#   theme(panel.spacing = unit(1, "lines")) +
#   theme(legend.position = "bottom", legend.title = element_blank(), legend.background = element_blank(), legend.box.background = element_rect(colour = "black"))

# habita labels for plots
## main labels

# habitat_labels <- c("Secondary Forest\n(LLAV)", "Primary Forest\n(MASE)", "Introduced Forest\n(MAIN)")
#habitat_labels <- c("Montane shrubland\n(SHRUB)", "Native Forest\n(NATIVE)", "Mixed Native & Introduced Forest\n(MIXED)")
habitat_labels <- c("SHRUB", "NATIVE", "MIXED")

## vector names
# names(habitat_labels) <- c("LLAV","MASE", "MAIN")
names(habitat_labels) <- c("SHRUB","NATIVE", "MIXED")

spp_trt$Species_SciName <- gsub("[\\(\\)]", "", regmatches(spp_trt$Species, gregexpr("\\(.*?\\)", spp_trt$Species)))
spp_trt$Species_SciName <- paste0(substr(spp_trt$Species_SciName,1,1),". ", sub("^\\S+\\s+", '', spp_trt$Species_SciName))
i.col <- which(colnames(spp_trt) %in% c("Specie.Code", "Species_SciName"))
spp_trt[,i.col[1]] <- as.character(spp_trt[,i.col[1]])
slopes.unique <- left_join(slopes.unique, spp_trt[,i.col], by = c("spp" = "Specie.Code"))
slopes <- left_join(slopes, spp_trt[,i.col], by = c("spp" = "Specie.Code"))
slopes$Species_SciName2 <- ordered(slopes$Species_SciName, levels = slopes.unique[order(slopes.unique$time_cts),]$Species_SciName)

slopes$Sig <- ifelse(slopes$time_ub2 < 0, "Significant", "Not Significant")


```




Site descriptions from MS
"We placed three sampling sites in areas with unique habitat types. 
These included: 
(1) native, mature secondary, subtropical moist broadleaf forest (NATIVE) located in Mazán; 
(2) mixed native and non-native forest (MIXED) also located in Mazán; and
(3) native montane shrubland (SHRUB) located in Llaviuco Valley."


Change labels from those used in earlier drafts of MS 
```{r}
slopes$loc.orig <- slopes$loc

slopes$loc <- gsub("LLAV","SHRUB",slopes$loc)
slopes$loc <- gsub("MAIN","MIXED",slopes$loc)
slopes$loc <- gsub("MASE","NATIVE",slopes$loc)

# set order
slopes$loc <- factor(slopes$loc, levels = c("NATIVE","MIXED","SHRUB"))
slopes$loc <- factor(slopes$loc, levels = c("SHRUB","MIXED","NATIVE"))
```

```{r}
summary(slopes$loc)
```



Save slopes

```{r}
write.csv(slopes, file = "species_specific_slops.csv")
```


```{r}
slopes
```
